/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const HIPRT_MAJOR_VERSION: u32 = 2;
pub const HIPRT_MINOR_VERSION: u32 = 3;
pub const HIPRT_PATCH_VERSION: u32 = 132093103;
pub const HIPRT_API_VERSION: u32 = 2003;
pub const HIPRT_VERSION_STR: &[u8; 6] = b"02003\0";
pub type std_integral_constant_value_type<_Ty> = _Ty;
pub type std_integral_constant_type = u8;
pub type std_bool_constant = u8;
pub type std_true_type = u8;
pub type std_conditional_type<_Ty1> = _Ty1;
pub type std_conditional_t = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std__Iterator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std__Iter_ref_t = std_iterator_traits;
pub type std__Iter_value_t = std_iterator_traits;
pub type std__Iter_diff_t = std_iterator_traits;
pub type std__Iter_cat_t = std_iterator_traits;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std_reverse_iterator<_BidIt> {
    pub current: _BidIt,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_BidIt>>,
}
pub type std_reverse_iterator_iterator_type<_BidIt> = _BidIt;
pub type std_reverse_iterator_iterator_category = std__Iter_cat_t;
pub type std_reverse_iterator_value_type = std__Iter_value_t;
pub type std_reverse_iterator_difference_type = std__Iter_diff_t;
pub type std_reverse_iterator_pointer = std_iterator_traits;
pub type std_reverse_iterator_reference = std__Iter_ref_t;
pub type std_reverse_iterator__Prevent_inheriting_unwrap<_BidIt> = std_reverse_iterator<_BidIt>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std__Rebind_alloc_t = std_allocator_traits;
#[repr(C)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator__From_primary = std_allocator;
pub type std_allocator_value_type<_Ty> = _Ty;
pub type std_allocator_pointer<_Ty> = *mut _Ty;
pub type std_allocator_const_pointer<_Ty> = *const _Ty;
pub type std_allocator_reference<_Ty> = *mut _Ty;
pub type std_allocator_const_reference<_Ty> = *const _Ty;
pub type std_allocator_size_type = ::std::os::raw::c_ulonglong;
pub type std_allocator_difference_type = ::std::os::raw::c_longlong;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std__Container_base0 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std__Iterator_base0 {
    pub _address: u8,
}
pub const std__Iterator_base0__Unwrap_when_unverified: bool = true;
pub type std__Container_base = std__Container_base0;
pub type std__Iterator_base = std__Iterator_base0;
pub type std__Compressed_pair__Mybase<_Ty1> = _Ty1;
pub type std_streamoff = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std_fpos<_Statetype> {
    pub _Myoff: std_streamoff,
    pub _Fpos: ::std::os::raw::c_longlong,
    pub _Mystate: _Statetype,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Statetype>>,
}
pub type std_streampos = std_fpos<_Mbstatet>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std__Char_traits {
    pub _address: u8,
}
pub type std__Char_traits_char_type<_Elem> = _Elem;
pub type std__Char_traits_int_type<_Int_type> = _Int_type;
pub type std__Char_traits_pos_type = std_streampos;
pub type std__Char_traits_off_type = std_streamoff;
pub type std__Char_traits_state_type = _Mbstatet;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
pub struct std__String_const_iterator {
    pub _Ptr: std__String_const_iterator_pointer,
}
pub type std__String_const_iterator_iterator_category = std_random_access_iterator_tag;
pub type std__String_const_iterator_value_type = [u8; 0usize];
pub type std__String_const_iterator_difference_type = [u8; 0usize];
pub type std__String_const_iterator_pointer = [u8; 0usize];
pub type std__String_const_iterator_reference = *const std__String_const_iterator_value_type;
pub type std__String_const_iterator__Prevent_inheriting_unwrap = std__String_const_iterator;
#[repr(C)]
pub struct std__String_iterator {
    pub _base: std__String_const_iterator,
}
pub type std__String_iterator__Mybase = std__String_const_iterator;
pub type std__String_iterator_iterator_category = std_random_access_iterator_tag;
pub type std__String_iterator_value_type = [u8; 0usize];
pub type std__String_iterator_difference_type = [u8; 0usize];
pub type std__String_iterator_pointer = [u8; 0usize];
pub type std__String_iterator_reference = *mut std__String_iterator_value_type;
pub type std__String_iterator__Prevent_inheriting_unwrap = std__String_iterator;
#[repr(C)]
pub struct std__String_val {
    pub _Bx: std__String_val__Bxty,
    pub _Mysize: std__String_val_size_type,
    pub _Myres: std__String_val_size_type,
}
pub type std__String_val_value_type = [u8; 0usize];
pub type std__String_val_size_type = [u8; 0usize];
pub type std__String_val_difference_type = [u8; 0usize];
pub type std__String_val_pointer = [u8; 0usize];
pub type std__String_val_const_pointer = [u8; 0usize];
pub type std__String_val_reference = *mut std__String_val_value_type;
pub type std__String_val_const_reference = *const std__String_val_value_type;
#[repr(C)]
pub struct std__String_val__Bxty {
    pub _Buf: __BindgenUnionField<*mut std__String_val_value_type>,
    pub _Ptr: __BindgenUnionField<std__String_val_pointer>,
    pub _Alias: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
pub struct std_basic_string {
    pub _Mypair: u8,
}
pub type std_basic_string__Alty = std__Rebind_alloc_t;
pub type std_basic_string__Alty_traits = std_allocator_traits;
pub type std_basic_string__Scary_val = std__String_val;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_allocator_type<_Alloc> = _Alloc;
pub type std_basic_string_value_type<_Elem> = _Elem;
pub type std_basic_string_size_type = std_basic_string__Alty_traits;
pub type std_basic_string_difference_type = std_basic_string__Alty_traits;
pub type std_basic_string_pointer = std_basic_string__Alty_traits;
pub type std_basic_string_const_pointer = std_basic_string__Alty_traits;
pub type std_basic_string_reference<_Elem> = *mut std_basic_string_value_type<_Elem>;
pub type std_basic_string_const_reference<_Elem> = *const std_basic_string_value_type<_Elem>;
pub type std_basic_string_iterator = std__String_iterator;
pub type std_basic_string_const_iterator = std__String_const_iterator;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string__Is_elem_cptr = std_bool_constant;
pub type std_string = std_basic_string;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprt_is_same {
    pub _address: u8,
}
pub const hiprt_is_same_value: hiprt_is_same__bindgen_ty_1 = hiprt_is_same__bindgen_ty_1(0);
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprt_is_same__bindgen_ty_1(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprt_remove_reference {
    pub _address: u8,
}
pub type hiprt_remove_reference_type<T> = T;
pub type hiprt_integral_constant_value_type<Ty> = Ty;
pub type hiprt_integral_constant_type = u8;
pub type hiprt_bool_constant = u8;
pub type hiprt_true_type = u8;
pub type hiprt_false_type = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprt_is_lvalue_reference {
    pub _base: hiprt_false_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprt_alignment_of {
    pub _address: u8,
}
pub type hiprt_conditional_type<T> = T;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprt_aligned_storage_type {
    pub data: *mut ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprt_Traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtInt2 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtFloat2 {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtInt3 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtFloat3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtInt4 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtFloat4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtUint2 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _hiprtGeometry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _hiprtScene {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _hiprtContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _hiprtFuncTable {
    _unused: [u8; 0],
}
pub type hiprtDevicePtr = *mut ::std::os::raw::c_void;
pub type hiprtGeometry = *mut _hiprtGeometry;
pub type hiprtScene = *mut _hiprtScene;
pub type hiprtContext = *mut _hiprtContext;
pub type hiprtFuncTable = *mut _hiprtFuncTable;
pub type hiprtLogLevel = u32;
pub type hiprtBuildFlags = u32;
pub type hiprtRayMask = u32;
pub type hiprtApiDevice = ::std::os::raw::c_int;
pub type hiprtApiCtx = *mut ::std::os::raw::c_void;
pub type hiprtApiStream = *mut ::std::os::raw::c_void;
pub type hiprtApiFunction = *mut ::std::os::raw::c_void;
pub type hiprtApiModule = *mut ::std::os::raw::c_void;
impl hiprtTraversalType {
    pub const hiprtTraversalTerminateAtAnyHit: hiprtTraversalType = hiprtTraversalType(1);
}
impl hiprtTraversalType {
    pub const hiprtTraversalTerminateAtClosestHit: hiprtTraversalType = hiprtTraversalType(2);
}
#[repr(transparent)]
#[doc = " \\brief Ray traversal type.\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtTraversalType(pub ::std::os::raw::c_int);
impl hiprtTraversalState {
    pub const hiprtTraversalStateInit: hiprtTraversalState = hiprtTraversalState(0);
}
impl hiprtTraversalState {
    pub const hiprtTraversalStateFinished: hiprtTraversalState = hiprtTraversalState(1);
}
impl hiprtTraversalState {
    pub const hiprtTraversalStateHit: hiprtTraversalState = hiprtTraversalState(2);
}
impl hiprtTraversalState {
    pub const hiprtTraversalStateStackOverflow: hiprtTraversalState = hiprtTraversalState(3);
}
#[repr(transparent)]
#[doc = " \\brief Traversal state.\n\n On-device traversal can be in either hit state (and can be continued using\n hiprtNextHit) or finished state."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtTraversalState(pub ::std::os::raw::c_int);
impl hiprtTraversalHint {
    pub const hiprtTraversalHintDefault: hiprtTraversalHint = hiprtTraversalHint(0);
}
impl hiprtTraversalHint {
    pub const hiprtTraversalHintShadowRays: hiprtTraversalHint = hiprtTraversalHint(1);
}
impl hiprtTraversalHint {
    pub const hiprtTraversalHintReflectionRays: hiprtTraversalHint = hiprtTraversalHint(2);
}
#[repr(transparent)]
#[doc = " \\brief Traversal hint.\n\n An additional information about the rays for the traversal object.\n It is taken into account only on AMD Navi3x (RDNA3) and above."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtTraversalHint(pub ::std::os::raw::c_int);
impl hiprtError {
    pub const hiprtSuccess: hiprtError = hiprtError(0);
}
impl hiprtError {
    pub const hiprtErrorNotImplemented: hiprtError = hiprtError(1);
}
impl hiprtError {
    pub const hiprtErrorInternal: hiprtError = hiprtError(2);
}
impl hiprtError {
    pub const hiprtErrorOutOfHostMemory: hiprtError = hiprtError(3);
}
impl hiprtError {
    pub const hiprtErrorOutOfDeviceMemory: hiprtError = hiprtError(4);
}
impl hiprtError {
    pub const hiprtErrorInvalidApiVersion: hiprtError = hiprtError(5);
}
impl hiprtError {
    pub const hiprtErrorInvalidParameter: hiprtError = hiprtError(6);
}
#[repr(transparent)]
#[doc = " \\brief Error codes.\n"]
#[must_use]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtError(pub ::std::os::raw::c_int);
impl hiprtLogLevelBits {
    pub const hiprtLogLevelNone: hiprtLogLevelBits = hiprtLogLevelBits(0);
}
impl hiprtLogLevelBits {
    pub const hiprtLogLevelInfo: hiprtLogLevelBits = hiprtLogLevelBits(1);
}
impl hiprtLogLevelBits {
    pub const hiprtLogLevelWarn: hiprtLogLevelBits = hiprtLogLevelBits(2);
}
impl hiprtLogLevelBits {
    pub const hiprtLogLevelError: hiprtLogLevelBits = hiprtLogLevelBits(4);
}
#[repr(transparent)]
#[doc = " \\brief Log levels.\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtLogLevelBits(pub ::std::os::raw::c_int);
impl hiprtBuildOperation {
    pub const hiprtBuildOperationBuild: hiprtBuildOperation = hiprtBuildOperation(1);
}
impl hiprtBuildOperation {
    pub const hiprtBuildOperationUpdate: hiprtBuildOperation = hiprtBuildOperation(2);
}
#[repr(transparent)]
#[doc = " \\brief Type of geometry/scene build operation.\n\n hiprtBuildGeometry/hiprtBuildScene can either build or update\n an underlying acceleration structure."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtBuildOperation(pub ::std::os::raw::c_int);
impl hiprtBuildFlagBits {
    pub const hiprtBuildFlagBitPreferFastBuild: hiprtBuildFlagBits = hiprtBuildFlagBits(0);
}
impl hiprtBuildFlagBits {
    pub const hiprtBuildFlagBitPreferBalancedBuild: hiprtBuildFlagBits = hiprtBuildFlagBits(1);
}
impl hiprtBuildFlagBits {
    pub const hiprtBuildFlagBitPreferHighQualityBuild: hiprtBuildFlagBits = hiprtBuildFlagBits(2);
}
impl hiprtBuildFlagBits {
    pub const hiprtBuildFlagBitCustomBvhImport: hiprtBuildFlagBits = hiprtBuildFlagBits(3);
}
impl hiprtBuildFlagBits {
    pub const hiprtBuildFlagBitDisableSpatialSplits: hiprtBuildFlagBits = hiprtBuildFlagBits(4);
}
impl hiprtBuildFlagBits {
    pub const hiprtBuildFlagBitDisableTrianglePairing: hiprtBuildFlagBits = hiprtBuildFlagBits(8);
}
#[repr(transparent)]
#[doc = " \\brief Hint flags for geometry/scene build functions.\n\n hiprtBuildGeometry/hiprtBuildScene use these flags to choose\n an appropriate build format/algorithm."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtBuildFlagBits(pub ::std::os::raw::c_int);
impl hiprtPrimitiveType {
    pub const hiprtPrimitiveTypeTriangleMesh: hiprtPrimitiveType = hiprtPrimitiveType(0);
}
impl hiprtPrimitiveType {
    pub const hiprtPrimitiveTypeAABBList: hiprtPrimitiveType = hiprtPrimitiveType(1);
}
#[repr(transparent)]
#[doc = " \\brief Geometric primitive type.\n\n hiprtGeometry can be built from multiple primitive types,\n such as triangle meshes, AABB lists, line lists, etc. This enum\n defines primitive type for hiprtBuildGeometry function."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtPrimitiveType(pub ::std::os::raw::c_int);
impl hiprtInstanceType {
    pub const hiprtInstanceTypeGeometry: hiprtInstanceType = hiprtInstanceType(0);
}
impl hiprtInstanceType {
    pub const hiprtInstanceTypeScene: hiprtInstanceType = hiprtInstanceType(1);
}
#[repr(transparent)]
#[doc = " \\brief Instance type.\n\n hiprtScene can be bult from instances either of hiprtGeometry or hiprtScene.\n This enum defines instance type for hiprtBuildScene function."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtInstanceType(pub ::std::os::raw::c_int);
impl hiprtPrimitiveNodeType {
    pub const hiprtTriangleNode: hiprtPrimitiveNodeType = hiprtPrimitiveNodeType(0);
}
impl hiprtPrimitiveNodeType {
    pub const hiprtCustomNode: hiprtPrimitiveNodeType = hiprtPrimitiveNodeType(1);
}
#[repr(transparent)]
#[doc = " \\brief Primitve types\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtPrimitiveNodeType(pub ::std::os::raw::c_int);
impl hiprtFrameType {
    pub const hiprtFrameTypeSRT: hiprtFrameType = hiprtFrameType(0);
}
impl hiprtFrameType {
    pub const hiprtFrameTypeMatrix: hiprtFrameType = hiprtFrameType(1);
}
#[repr(transparent)]
#[doc = " \\brief Transformation frame type.\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtFrameType(pub ::std::os::raw::c_int);
impl hiprtStackType {
    pub const hiprtStackTypeGlobal: hiprtStackType = hiprtStackType(0);
}
impl hiprtStackType {
    pub const hiprtStackTypeDynamic: hiprtStackType = hiprtStackType(1);
}
#[repr(transparent)]
#[doc = " \\brief Stack type.\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtStackType(pub ::std::os::raw::c_int);
impl hiprtStackEntryType {
    pub const hiprtStackEntryTypeInteger: hiprtStackEntryType = hiprtStackEntryType(0);
}
impl hiprtStackEntryType {
    pub const hiprtStackEntryTypeInstance: hiprtStackEntryType = hiprtStackEntryType(1);
}
#[repr(transparent)]
#[doc = " \\brief Stack entry type.\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtStackEntryType(pub ::std::os::raw::c_int);
impl hiprtBvhNodeType {
    pub const hiprtBvhNodeTypeInternal: hiprtBvhNodeType = hiprtBvhNodeType(0);
}
impl hiprtBvhNodeType {
    pub const hiprtBvhNodeTypeLeaf: hiprtBvhNodeType = hiprtBvhNodeType(1);
}
#[repr(transparent)]
#[doc = " \\brief Bvh node type.\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtBvhNodeType(pub ::std::os::raw::c_int);
#[doc = " \\brief Ray data structure.\n"]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct hiprtRay {
    pub origin: hiprtFloat3,
    pub minT: f32,
    pub direction: hiprtFloat3,
    pub maxT: f32,
}
#[doc = " \\brief Ray hit data structure.\n"]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct hiprtHit {
    pub __bindgen_anon_1: hiprtHit__bindgen_ty_1,
    pub primID: u32,
    pub uv: hiprtFloat2,
    pub normal: hiprtFloat3,
    pub t: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hiprtHit__bindgen_ty_1 {
    pub instanceID: u32,
    pub instanceIDs: [u32; 4usize],
}
#[doc = " \\brief Set of device data pointers for custom functions.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtFuncDataSet {
    pub intersectFuncData: *const ::std::os::raw::c_void,
    pub filterFuncData: *const ::std::os::raw::c_void,
}
#[doc = " \\brief A header of the function table.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtFuncTableHeader {
    pub numGeomTypes: u32,
    pub numRayTypes: u32,
    pub funcDataSets: *mut hiprtFuncDataSet,
}
#[doc = " \\brief A header of the global stack buffer.\n Use API functions to create this buffer.\n - hiprtCreateStackBuffer\n - hiprtDestroyStackBuffer"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtGlobalStackBuffer {
    pub stackSize: u32,
    pub stackCount: u32,
    pub stackData: *mut ::std::os::raw::c_void,
}
#[doc = " \\brief A header of the shared stack buffer.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtSharedStackBuffer {
    pub stackSize: u32,
    pub stackData: *mut ::std::os::raw::c_void,
}
#[doc = " \\brief Set of function names.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtFuncNameSet {
    pub intersectFuncName: *const ::std::os::raw::c_char,
    pub filterFuncName: *const ::std::os::raw::c_char,
}
impl hiprtDeviceType {
    pub const hiprtDeviceAMD: hiprtDeviceType = hiprtDeviceType(0);
}
impl hiprtDeviceType {
    pub const hiprtDeviceNVIDIA: hiprtDeviceType = hiprtDeviceType(1);
}
#[repr(transparent)]
#[doc = " \\brief Device type.\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtDeviceType(pub ::std::os::raw::c_int);
#[doc = " \\brief Context creation input.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtContextCreationInput {
    pub ctxt: hiprtApiCtx,
    pub device: hiprtApiDevice,
    pub deviceType: hiprtDeviceType,
}
#[doc = " \\brief Various flags controlling scene/geometry build process.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtBuildOptions {
    pub buildFlags: hiprtBuildFlags,
    pub batchBuildMaxPrimCount: u32,
}
#[doc = " \\brief Triangle mesh primitive.\n\n Triangle mesh primitive is represented as an indexed vertex array.\n Vertex and index arrays are defined using device pointers and strides.\n Each vertex has to have 3 components: (x, y, z) coordinates.\n Indices are organized into triples (i0, i1, i2) - one for each triangle.\n If the indices are not provided, it assumes (3*t+0, 3*t+1, 3*t+2)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtTriangleMeshPrimitive {
    pub vertices: hiprtDevicePtr,
    pub vertexCount: u32,
    pub vertexStride: u32,
    pub triangleIndices: hiprtDevicePtr,
    pub triangleCount: u32,
    pub triangleStride: u32,
    pub trianglePairIndices: hiprtDevicePtr,
    pub trianglePairCount: u32,
}
#[doc = " \\brief AABB list primitive.\n\n AABB list is an array of axis aligned bounding boxes, represented\n by device memory pointer and stride between two consecutive boxes.\n Each AABB is a pair of float3 or float4 values."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtAABBListPrimitive {
    pub aabbs: hiprtDevicePtr,
    pub aabbCount: u32,
    pub aabbStride: u32,
}
#[doc = " \\brief Bvh node for custom import Bvh.\n"]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hiprtBvhNode {
    pub childIndices: [u32; 4usize],
    pub childNodeTypes: [hiprtBvhNodeType; 4usize],
    pub childAabbsMin: [hiprtFloat3; 4usize],
    pub childAabbsMax: [hiprtFloat3; 4usize],
}
#[doc = " \\brief Bvh node list.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtBvhNodeList {
    pub nodes: hiprtDevicePtr,
    pub nodeCount: u32,
}
#[doc = " \\brief Build input for geometry build/update operation.\n\n Build input defines concrete primitive type and a pointer to an actual\n primitive description."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hiprtGeometryBuildInput {
    pub type_: hiprtPrimitiveType,
    pub geomType: u32,
    pub primitive: hiprtGeometryBuildInput__bindgen_ty_1,
    pub nodeList: hiprtBvhNodeList,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hiprtGeometryBuildInput__bindgen_ty_1 {
    pub triangleMesh: hiprtTriangleMeshPrimitive,
    pub aabbList: hiprtAABBListPrimitive,
}
#[doc = " \\brief Instance containing a pointer to the actual geometry/scene.\n"]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct hiprtInstance {
    pub type_: hiprtInstanceType,
    pub __bindgen_anon_1: hiprtInstance__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hiprtInstance__bindgen_ty_1 {
    pub geometry: hiprtGeometry,
    pub scene: hiprtScene,
}
#[doc = " \\brief Build input for the scene.\n\n Scene consists of a set of instances. Each of the instances is defined by:\n  - Root pointer of the corresponding geometry\n  - Transformation header\n  - Mask\n\n Instances can refer to the same geometry but with different transformations\n (essentially implementing instancing). Mask is used to implement ray\n masking: ray mask is bitwise &ded with an instance mask, and no intersections\n are evaluated with the primitive of corresponding instance if the result is\n 0. The transformation header defines the offset and the number of consecutive\n transformation frames in the frame array for each instance. More than one frame\n is interpreted as motion blur. If the transformation headers is NULL, it\n assumes one frame per instance. Optionally, it is possible to import a custom\n BVH by setting nodes and the corresponding build flag."]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct hiprtSceneBuildInput {
    pub instances: hiprtDevicePtr,
    pub instanceTransformHeaders: hiprtDevicePtr,
    pub instanceFrames: hiprtDevicePtr,
    pub instanceMasks: hiprtDevicePtr,
    pub nodeList: hiprtBvhNodeList,
    pub instanceCount: u32,
    pub frameCount: u32,
    pub frameType: hiprtFrameType,
}
#[doc = " \\brief Input for the global stack buffer allocation\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtGlobalStackBufferInput {
    pub type_: hiprtStackType,
    pub entryType: hiprtStackEntryType,
    pub stackSize: u32,
    pub threadCount: u32,
}
#[doc = " \\brief Stack entry for instace stacks\n"]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct hiprtInstanceStackEntry {
    pub ray: hiprtRay,
    pub scene: hiprtScene,
}
#[doc = " \\brief SRT transformation frame.\n\n Represented by scale (S), rotation (R), translation (T), and frame time.\n Object to world transformation is composed as (T * R * S) * x = y"]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct hiprtFrameSRT {
    pub rotation: hiprtFloat4,
    pub scale: hiprtFloat3,
    pub translation: hiprtFloat3,
    pub time: f32,
}
#[doc = " \\brief Transformation matrix frame representation.\n\n Represented by a 3x4 matrix and frame time."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hiprtFrameMatrix {
    pub matrix: [[f32; 4usize]; 3usize],
    pub time: f32,
}
#[doc = " \\brief Transformation header.\n\n Defines defines the index to the array of frames and the number of frames."]
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct hiprtTransformHeader {
    pub frameIndex: u32,
    pub frameCount: u32,
}
extern crate libloading;
pub struct HipRt {
    __library: ::libloading::Library,
    pub hiprtCreateContext: Result<
        unsafe extern "C" fn(
            hiprtApiVersion: u32,
            input: *const hiprtContextCreationInput,
            contextOut: *mut hiprtContext,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtDestroyContext:
        Result<unsafe extern "C" fn(context: hiprtContext) -> hiprtError, ::libloading::Error>,
    pub hiprtCreateGeometry: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildInput: *const hiprtGeometryBuildInput,
            buildOptions: hiprtBuildOptions,
            geometryOut: *mut hiprtGeometry,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtCreateGeometries: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            numGeometries: u32,
            buildInputs: *const hiprtGeometryBuildInput,
            buildOptions: hiprtBuildOptions,
            geometriesOut: *mut *mut hiprtGeometry,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtDestroyGeometry: Result<
        unsafe extern "C" fn(context: hiprtContext, geometry: hiprtGeometry) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtDestroyGeometries: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            numGeometries: u32,
            geometries: *mut hiprtGeometry,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtBuildGeometry: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildOperation: hiprtBuildOperation,
            buildInput: *const hiprtGeometryBuildInput,
            buildOptions: hiprtBuildOptions,
            temporaryBuffer: hiprtDevicePtr,
            stream: hiprtApiStream,
            geometryOut: hiprtGeometry,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtBuildGeometries: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildOperation: hiprtBuildOperation,
            numGeometries: u32,
            buildInputs: *const hiprtGeometryBuildInput,
            buildOptions: hiprtBuildOptions,
            temporaryBuffer: hiprtDevicePtr,
            stream: hiprtApiStream,
            geometriesOut: *mut hiprtGeometry,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtGetGeometryBuildTemporaryBufferSize: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildInput: *const hiprtGeometryBuildInput,
            buildOptions: hiprtBuildOptions,
            sizeOut: *mut usize,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtGetGeometriesBuildTemporaryBufferSize: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            numGeometries: u32,
            buildInputs: *const hiprtGeometryBuildInput,
            buildOptions: hiprtBuildOptions,
            sizeOut: *mut usize,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtCompactGeometry: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            stream: hiprtApiStream,
            geometryIn: hiprtGeometry,
            geometryOut: *mut hiprtGeometry,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtCompactGeometries: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            numGeometries: u32,
            stream: hiprtApiStream,
            geometriesIn: *mut hiprtGeometry,
            geometriesOut: *mut *mut hiprtGeometry,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtCreateScene: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildInput: *const hiprtSceneBuildInput,
            buildOptions: hiprtBuildOptions,
            sceneOut: *mut hiprtScene,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtCreateScenes: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            numScenes: u32,
            buildInputs: *const hiprtSceneBuildInput,
            buildOptions: hiprtBuildOptions,
            scenesOut: *mut *mut hiprtScene,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtDestroyScene: Result<
        unsafe extern "C" fn(context: hiprtContext, scene: hiprtScene) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtDestroyScenes: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            numScenes: u32,
            scenes: *mut hiprtScene,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtBuildScene: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildOperation: hiprtBuildOperation,
            buildInput: *const hiprtSceneBuildInput,
            buildOptions: hiprtBuildOptions,
            temporaryBuffer: hiprtDevicePtr,
            stream: hiprtApiStream,
            sceneOut: hiprtScene,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtBuildScenes: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildOperation: hiprtBuildOperation,
            numScenes: u32,
            buildInputs: *const hiprtSceneBuildInput,
            buildOptions: hiprtBuildOptions,
            temporaryBuffer: hiprtDevicePtr,
            stream: hiprtApiStream,
            scenesOut: *mut hiprtScene,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtGetSceneBuildTemporaryBufferSize: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildInput: *const hiprtSceneBuildInput,
            buildOptions: hiprtBuildOptions,
            sizeOut: *mut usize,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtGetScenesBuildTemporaryBufferSize: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            numScenes: u32,
            buildInput: *const hiprtSceneBuildInput,
            buildOptions: hiprtBuildOptions,
            sizeOut: *mut usize,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtCompactScene: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            stream: hiprtApiStream,
            sceneIn: hiprtScene,
            sceneOut: *mut hiprtScene,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtCompactScenes: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            numScenes: u32,
            stream: hiprtApiStream,
            scenesIn: *mut hiprtScene,
            scenesOut: *mut *mut hiprtScene,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtCreateFuncTable: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            numGeomTypes: u32,
            numRayTypes: u32,
            funcTableOut: *mut hiprtFuncTable,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtSetFuncTable: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            funcTable: hiprtFuncTable,
            geomType: u32,
            rayType: u32,
            set: hiprtFuncDataSet,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtDestroyFuncTable: Result<
        unsafe extern "C" fn(context: hiprtContext, funcTable: hiprtFuncTable) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtCreateGlobalStackBuffer: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            input: *const hiprtGlobalStackBufferInput,
            stackBufferOut: *mut hiprtGlobalStackBuffer,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtDestroyGlobalStackBuffer: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            stackBuffer: hiprtGlobalStackBuffer,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtSaveGeometry: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            geometry: hiprtGeometry,
            filename: *const ::std::os::raw::c_char,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtLoadGeometry: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            geometryOut: *mut hiprtGeometry,
            filename: *const ::std::os::raw::c_char,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtSaveScene: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            scene: hiprtScene,
            filename: *const ::std::os::raw::c_char,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtLoadScene: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            sceneOut: *mut hiprtScene,
            filename: *const ::std::os::raw::c_char,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtExportGeometryAabb: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            geometry: hiprtGeometry,
            aabbMinOut: *mut hiprtFloat3,
            aabbMaxOut: *mut hiprtFloat3,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtExportSceneAabb: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            scene: hiprtScene,
            aabbMinOut: *mut hiprtFloat3,
            aabbMaxOut: *mut hiprtFloat3,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtBuildTraceKernels: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            numFunctions: u32,
            funcNames: *mut *const ::std::os::raw::c_char,
            src: *const ::std::os::raw::c_char,
            moduleName: *const ::std::os::raw::c_char,
            numHeaders: u32,
            headers: *mut *const ::std::os::raw::c_char,
            includeNames: *mut *const ::std::os::raw::c_char,
            numOptions: u32,
            options: *mut *const ::std::os::raw::c_char,
            numGeomTypes: u32,
            numRayTypes: u32,
            funcNameSets: *mut hiprtFuncNameSet,
            functionsOut: *mut hiprtApiFunction,
            moduleOut: *mut hiprtApiModule,
            cache: bool,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtBuildTraceKernelsFromBitcode: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            numFunctions: u32,
            funcNames: *mut *const ::std::os::raw::c_char,
            moduleName: *const ::std::os::raw::c_char,
            bitcodeBinary: *const ::std::os::raw::c_char,
            bitcodeBinarySize: usize,
            numGeomTypes: u32,
            numRayTypes: u32,
            funcNameSets: *mut hiprtFuncNameSet,
            functionsOut: *mut hiprtApiFunction,
            cache: bool,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtSetCacheDirPath: Result<
        unsafe extern "C" fn(context: hiprtContext, path: *const ::std::os::raw::c_char),
        ::libloading::Error,
    >,
    pub hiprtSetLogLevel: Result<unsafe extern "C" fn(level: hiprtLogLevel), ::libloading::Error>,
}
impl HipRt {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let hiprtCreateContext = __library.get(b"hiprtCreateContext\0").map(|sym| *sym);
        let hiprtDestroyContext = __library.get(b"hiprtDestroyContext\0").map(|sym| *sym);
        let hiprtCreateGeometry = __library.get(b"hiprtCreateGeometry\0").map(|sym| *sym);
        let hiprtCreateGeometries = __library.get(b"hiprtCreateGeometries\0").map(|sym| *sym);
        let hiprtDestroyGeometry = __library.get(b"hiprtDestroyGeometry\0").map(|sym| *sym);
        let hiprtDestroyGeometries = __library.get(b"hiprtDestroyGeometries\0").map(|sym| *sym);
        let hiprtBuildGeometry = __library.get(b"hiprtBuildGeometry\0").map(|sym| *sym);
        let hiprtBuildGeometries = __library.get(b"hiprtBuildGeometries\0").map(|sym| *sym);
        let hiprtGetGeometryBuildTemporaryBufferSize = __library
            .get(b"hiprtGetGeometryBuildTemporaryBufferSize\0")
            .map(|sym| *sym);
        let hiprtGetGeometriesBuildTemporaryBufferSize = __library
            .get(b"hiprtGetGeometriesBuildTemporaryBufferSize\0")
            .map(|sym| *sym);
        let hiprtCompactGeometry = __library.get(b"hiprtCompactGeometry\0").map(|sym| *sym);
        let hiprtCompactGeometries = __library.get(b"hiprtCompactGeometries\0").map(|sym| *sym);
        let hiprtCreateScene = __library.get(b"hiprtCreateScene\0").map(|sym| *sym);
        let hiprtCreateScenes = __library.get(b"hiprtCreateScenes\0").map(|sym| *sym);
        let hiprtDestroyScene = __library.get(b"hiprtDestroyScene\0").map(|sym| *sym);
        let hiprtDestroyScenes = __library.get(b"hiprtDestroyScenes\0").map(|sym| *sym);
        let hiprtBuildScene = __library.get(b"hiprtBuildScene\0").map(|sym| *sym);
        let hiprtBuildScenes = __library.get(b"hiprtBuildScenes\0").map(|sym| *sym);
        let hiprtGetSceneBuildTemporaryBufferSize = __library
            .get(b"hiprtGetSceneBuildTemporaryBufferSize\0")
            .map(|sym| *sym);
        let hiprtGetScenesBuildTemporaryBufferSize = __library
            .get(b"hiprtGetScenesBuildTemporaryBufferSize\0")
            .map(|sym| *sym);
        let hiprtCompactScene = __library.get(b"hiprtCompactScene\0").map(|sym| *sym);
        let hiprtCompactScenes = __library.get(b"hiprtCompactScenes\0").map(|sym| *sym);
        let hiprtCreateFuncTable = __library.get(b"hiprtCreateFuncTable\0").map(|sym| *sym);
        let hiprtSetFuncTable = __library.get(b"hiprtSetFuncTable\0").map(|sym| *sym);
        let hiprtDestroyFuncTable = __library.get(b"hiprtDestroyFuncTable\0").map(|sym| *sym);
        let hiprtCreateGlobalStackBuffer = __library
            .get(b"hiprtCreateGlobalStackBuffer\0")
            .map(|sym| *sym);
        let hiprtDestroyGlobalStackBuffer = __library
            .get(b"hiprtDestroyGlobalStackBuffer\0")
            .map(|sym| *sym);
        let hiprtSaveGeometry = __library.get(b"hiprtSaveGeometry\0").map(|sym| *sym);
        let hiprtLoadGeometry = __library.get(b"hiprtLoadGeometry\0").map(|sym| *sym);
        let hiprtSaveScene = __library.get(b"hiprtSaveScene\0").map(|sym| *sym);
        let hiprtLoadScene = __library.get(b"hiprtLoadScene\0").map(|sym| *sym);
        let hiprtExportGeometryAabb = __library.get(b"hiprtExportGeometryAabb\0").map(|sym| *sym);
        let hiprtExportSceneAabb = __library.get(b"hiprtExportSceneAabb\0").map(|sym| *sym);
        let hiprtBuildTraceKernels = __library.get(b"hiprtBuildTraceKernels\0").map(|sym| *sym);
        let hiprtBuildTraceKernelsFromBitcode = __library
            .get(b"hiprtBuildTraceKernelsFromBitcode\0")
            .map(|sym| *sym);
        let hiprtSetCacheDirPath = __library.get(b"hiprtSetCacheDirPath\0").map(|sym| *sym);
        let hiprtSetLogLevel = __library.get(b"hiprtSetLogLevel\0").map(|sym| *sym);
        Ok(HipRt {
            __library,
            hiprtCreateContext,
            hiprtDestroyContext,
            hiprtCreateGeometry,
            hiprtCreateGeometries,
            hiprtDestroyGeometry,
            hiprtDestroyGeometries,
            hiprtBuildGeometry,
            hiprtBuildGeometries,
            hiprtGetGeometryBuildTemporaryBufferSize,
            hiprtGetGeometriesBuildTemporaryBufferSize,
            hiprtCompactGeometry,
            hiprtCompactGeometries,
            hiprtCreateScene,
            hiprtCreateScenes,
            hiprtDestroyScene,
            hiprtDestroyScenes,
            hiprtBuildScene,
            hiprtBuildScenes,
            hiprtGetSceneBuildTemporaryBufferSize,
            hiprtGetScenesBuildTemporaryBufferSize,
            hiprtCompactScene,
            hiprtCompactScenes,
            hiprtCreateFuncTable,
            hiprtSetFuncTable,
            hiprtDestroyFuncTable,
            hiprtCreateGlobalStackBuffer,
            hiprtDestroyGlobalStackBuffer,
            hiprtSaveGeometry,
            hiprtLoadGeometry,
            hiprtSaveScene,
            hiprtLoadScene,
            hiprtExportGeometryAabb,
            hiprtExportSceneAabb,
            hiprtBuildTraceKernels,
            hiprtBuildTraceKernelsFromBitcode,
            hiprtSetCacheDirPath,
            hiprtSetLogLevel,
        })
    }
    #[must_use]
    #[doc = " \\brief Creates HIPRT API context.\n\n All HIPRT functions expect context as their first argument. Context\n keeps global data required by HIPRT session. Calls made from different\n threads with different HIPRT contexts are safe. Calls with the same context\n should be externally synchronized by the client.\n\n \\param hiprtApiVersion The API version.\n \\param contextOut The created context.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCreateContext(
        &self,
        hiprtApiVersion: u32,
        input: *const hiprtContextCreationInput,
        contextOut: *mut hiprtContext,
    ) -> hiprtError {
        (self
            .hiprtCreateContext
            .as_ref()
            .expect("Expected function, got error."))(hiprtApiVersion, input, contextOut)
    }
    #[must_use]
    #[doc = " \\brief Destorys the HIPRT API context.\n\n Destroys all the global resources used by HIPRT session. Further calls\n with this context are prohibited.\n\n \\param context The API context.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtDestroyContext(&self, context: hiprtContext) -> hiprtError {
        (self
            .hiprtDestroyContext
            .as_ref()
            .expect("Expected function, got error."))(context)
    }
    #[must_use]
    #[doc = " \\brief Creates a geometry.\n\n This function creates\n hiprtGeometry representing acceleration structure topology.\n\n \\param context The HIPRT API context.\n \\param buildInput An input parameters for the build.\n \\param buildOptions Various flags controlling build process.\n \\param geometryOut The resulting geometry.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCreateGeometry(
        &self,
        context: hiprtContext,
        buildInput: *const hiprtGeometryBuildInput,
        buildOptions: hiprtBuildOptions,
        geometryOut: *mut hiprtGeometry,
    ) -> hiprtError {
        (self
            .hiprtCreateGeometry
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            buildInput,
            buildOptions,
            geometryOut,
        )
    }
    #[must_use]
    #[doc = " \\brief Creates geometries.\n\n This function creates an array of\n hiprtGeometry representing acceleration structure topology.\n\n \\param context The HIPRT API context.\n \\param numGeometries The number of geometries to be created.\n \\param buildInputs An array of build input structs.\n \\param buildOptions Various flags controlling build process.\n \\param geometriesOut The resulting geometries.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCreateGeometries(
        &self,
        context: hiprtContext,
        numGeometries: u32,
        buildInputs: *const hiprtGeometryBuildInput,
        buildOptions: hiprtBuildOptions,
        geometriesOut: *mut *mut hiprtGeometry,
    ) -> hiprtError {
        (self
            .hiprtCreateGeometries
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            numGeometries,
            buildInputs,
            buildOptions,
            geometriesOut,
        )
    }
    #[must_use]
    #[doc = " \\brief Destroys a geometry.\n\n This function destroys\n hiprtGeometry representing acceleration structure topology.\n\n \\param context The HIPRT API context.\n \\param geometry The geometry.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtDestroyGeometry(
        &self,
        context: hiprtContext,
        geometry: hiprtGeometry,
    ) -> hiprtError {
        (self
            .hiprtDestroyGeometry
            .as_ref()
            .expect("Expected function, got error."))(context, geometry)
    }
    #[must_use]
    #[doc = " \\brief Destroys geometries.\n\n This function destroys an array of\n hiprtGeometry representing acceleration structure topology.\n\n \\param context The HIPRT API context.\n \\param numGeometries The number of geometries to be created.\n \\param geometry The geometries.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtDestroyGeometries(
        &self,
        context: hiprtContext,
        numGeometries: u32,
        geometries: *mut hiprtGeometry,
    ) -> hiprtError {
        (self
            .hiprtDestroyGeometries
            .as_ref()
            .expect("Expected function, got error."))(context, numGeometries, geometries)
    }
    #[must_use]
    #[doc = " \\brief Builds or updates a geometry.\n\n Given geometry description from the client, this function builds\n hiprtGeometry representing acceleration structure topology (in case of a\n build) or updates acceleration structure keeping topology intact (update).\n\n \\param context The HIPRT API context.\n \\param buildOperation The type of the build operation.\n \\param buildInput An input parameters for the build.\n \\param buildOptions Various flags controlling build process.\n \\param temporaryBuffer A temporary buffer for the build.\n \\param stream A stream used for the build.\n \\param geometryOut Resulting geometry.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtBuildGeometry(
        &self,
        context: hiprtContext,
        buildOperation: hiprtBuildOperation,
        buildInput: *const hiprtGeometryBuildInput,
        buildOptions: hiprtBuildOptions,
        temporaryBuffer: hiprtDevicePtr,
        stream: hiprtApiStream,
        geometryOut: hiprtGeometry,
    ) -> hiprtError {
        (self
            .hiprtBuildGeometry
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            buildOperation,
            buildInput,
            buildOptions,
            temporaryBuffer,
            stream,
            geometryOut,
        )
    }
    #[must_use]
    #[doc = " \\brief Builds or updates geometries.\n\n Given geometry description from the client, this function builds\n hiprtGeometry representing acceleration structure topology (in case of a\n build) or updates acceleration structure keeping topology intact (update).\n\n \\param context The HIPRT API context.\n \\param buildOperation The type of the build operation.\n \\param numGeometries The number of geometries to be built.\n \\param buildInputs An array of build input structs.\n \\param buildOptions Various flags controlling build process.\n \\param temporaryBuffer A temporary buffer for the build.\n \\param stream A stream used for the build.\n \\param geometriesOut Resulting geometries.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtBuildGeometries(
        &self,
        context: hiprtContext,
        buildOperation: hiprtBuildOperation,
        numGeometries: u32,
        buildInputs: *const hiprtGeometryBuildInput,
        buildOptions: hiprtBuildOptions,
        temporaryBuffer: hiprtDevicePtr,
        stream: hiprtApiStream,
        geometriesOut: *mut hiprtGeometry,
    ) -> hiprtError {
        (self
            .hiprtBuildGeometries
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            buildOperation,
            numGeometries,
            buildInputs,
            buildOptions,
            temporaryBuffer,
            stream,
            geometriesOut,
        )
    }
    #[must_use]
    #[doc = " \\brief Returns temporary storage requirements for geometry build.\n\n \\param context The HIPRT API context.\n \\param buildInput An input parameters for the build.\n \\param buildOptions Various flags controlling build process.\n \\param sizeOut The resulting size.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtGetGeometryBuildTemporaryBufferSize(
        &self,
        context: hiprtContext,
        buildInput: *const hiprtGeometryBuildInput,
        buildOptions: hiprtBuildOptions,
        sizeOut: *mut usize,
    ) -> hiprtError {
        (self
            .hiprtGetGeometryBuildTemporaryBufferSize
            .as_ref()
            .expect("Expected function, got error."))(
            context, buildInput, buildOptions, sizeOut
        )
    }
    #[must_use]
    #[doc = " \\brief Returns temporary storage requirements for geometry build.\n\n \\param context The HIPRT API context.\n \\param numGeometries The number of geometries to be built.\n \\param buildInputs An array of build input structs.\n \\param buildOptions Various flags controlling build process.\n \\param sizeOut The resulting size.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtGetGeometriesBuildTemporaryBufferSize(
        &self,
        context: hiprtContext,
        numGeometries: u32,
        buildInputs: *const hiprtGeometryBuildInput,
        buildOptions: hiprtBuildOptions,
        sizeOut: *mut usize,
    ) -> hiprtError {
        (self
            .hiprtGetGeometriesBuildTemporaryBufferSize
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            numGeometries,
            buildInputs,
            buildOptions,
            sizeOut,
        )
    }
    #[must_use]
    #[doc = " \\brief Compacts geometry.\n\n This function compacts hiprtGeometry, reducing used memory.\n The input geometry are automatically destroyed.\n\n \\param context The HIPRT API context.\n \\param stream A stream used for the compaction.\n \\param geometryIn The input geometry to be compacted.\n \\param geometryOut The compacted geometry.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCompactGeometry(
        &self,
        context: hiprtContext,
        stream: hiprtApiStream,
        geometryIn: hiprtGeometry,
        geometryOut: *mut hiprtGeometry,
    ) -> hiprtError {
        (self
            .hiprtCompactGeometry
            .as_ref()
            .expect("Expected function, got error."))(
            context, stream, geometryIn, geometryOut
        )
    }
    #[must_use]
    #[doc = " \\brief Compacts geometries.\n\n This function compacts an array of\n hiprtGeometry, reducing used memory.\n The input geometries are automatically destroyed.\n\n \\param context The HIPRT API context.\n \\param numGeometries The number of geometries to be compacted.\n \\param stream A stream used for the compaction.\n \\param geometriesIn The input geometries to be compacted.\n \\param geometriesOut The compacted geometries.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCompactGeometries(
        &self,
        context: hiprtContext,
        numGeometries: u32,
        stream: hiprtApiStream,
        geometriesIn: *mut hiprtGeometry,
        geometriesOut: *mut *mut hiprtGeometry,
    ) -> hiprtError {
        (self
            .hiprtCompactGeometries
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            numGeometries,
            stream,
            geometriesIn,
            geometriesOut,
        )
    }
    #[must_use]
    #[doc = " \\brief Creates a scene.\n\n This function creates\n hiprtScene representing acceleration structure topology.\n\n \\param context The HIPRT API context.\n \\param buildInput An input parameters for the build.\n \\param buildOptions Various flags controlling build process.\n \\param sceneOut The resulting scene.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCreateScene(
        &self,
        context: hiprtContext,
        buildInput: *const hiprtSceneBuildInput,
        buildOptions: hiprtBuildOptions,
        sceneOut: *mut hiprtScene,
    ) -> hiprtError {
        (self
            .hiprtCreateScene
            .as_ref()
            .expect("Expected function, got error."))(
            context, buildInput, buildOptions, sceneOut
        )
    }
    #[must_use]
    #[doc = " \\brief Creates scenes.\n\n This function creates\n hiprtScene representing acceleration structure topology.\n\n \\param context The HIPRT API context.\n \\param numScenes The number of scenes to be created.\n \\param buildInputs An array of build input structs.\n \\param buildOptions Various flags controlling build process.\n \\param scenesOut The resulting scenes.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCreateScenes(
        &self,
        context: hiprtContext,
        numScenes: u32,
        buildInputs: *const hiprtSceneBuildInput,
        buildOptions: hiprtBuildOptions,
        scenesOut: *mut *mut hiprtScene,
    ) -> hiprtError {
        (self
            .hiprtCreateScenes
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            numScenes,
            buildInputs,
            buildOptions,
            scenesOut,
        )
    }
    #[must_use]
    #[doc = " \\brief Destroys a scene.\n\n This function destroys\n hiprtScene representing acceleration structure topology.\n\n \\param context The HIPRT API context.\n \\param scene The scene.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtDestroyScene(&self, context: hiprtContext, scene: hiprtScene) -> hiprtError {
        (self
            .hiprtDestroyScene
            .as_ref()
            .expect("Expected function, got error."))(context, scene)
    }
    #[must_use]
    #[doc = " \\brief Destroys scenes.\n\n This function destroys array of\n hiprtScene representing acceleration structure topology.\n\n \\param context The HIPRT API context.\n \\param numScenes The number of scenes to be destroyed.\n \\param scenes The scenes.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtDestroyScenes(
        &self,
        context: hiprtContext,
        numScenes: u32,
        scenes: *mut hiprtScene,
    ) -> hiprtError {
        (self
            .hiprtDestroyScenes
            .as_ref()
            .expect("Expected function, got error."))(context, numScenes, scenes)
    }
    #[must_use]
    #[doc = " \\brief Builds or updates a scene.\n\n Given a number of hiprtGeometries from the client, this function builds\n hiprtScene representing top level acceleration structure topology (in case of\n a build) or updates acceleration structure keeping topology intact (update).\n\n \\param context The HIPRT API context.\n \\param buildOperation The type of the build operation.\n \\param buildInput An input parameters for the build.\n \\param buildOptions Various flags controlling build process.\n \\param temporaryBuffer A temporary buffer for build operation.\n \\param stream A stream used for the build.\n \\param sceneOut The resulting scene.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtBuildScene(
        &self,
        context: hiprtContext,
        buildOperation: hiprtBuildOperation,
        buildInput: *const hiprtSceneBuildInput,
        buildOptions: hiprtBuildOptions,
        temporaryBuffer: hiprtDevicePtr,
        stream: hiprtApiStream,
        sceneOut: hiprtScene,
    ) -> hiprtError {
        (self
            .hiprtBuildScene
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            buildOperation,
            buildInput,
            buildOptions,
            temporaryBuffer,
            stream,
            sceneOut,
        )
    }
    #[must_use]
    #[doc = " \\brief Builds or updates scenes.\n\n Given a number of hiprtGeometries from the client, this function builds\n hiprtScene representing top level acceleration structure topology (in case of\n a build) or updates acceleration structure keeping topology intact (update).\n\n \\param context The HIPRT API context.\n \\param buildOperation The type of the build operation.\n \\param numScenes The number of scenes to be built.\n \\param buildInputs An array of build input structs.\n \\param buildOptions Various flags controlling build process.\n \\param temporaryBuffer A temporary buffer for build operation.\n \\param stream A stream used for the build.\n \\param scenesOut The resulting scenes.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtBuildScenes(
        &self,
        context: hiprtContext,
        buildOperation: hiprtBuildOperation,
        numScenes: u32,
        buildInputs: *const hiprtSceneBuildInput,
        buildOptions: hiprtBuildOptions,
        temporaryBuffer: hiprtDevicePtr,
        stream: hiprtApiStream,
        scenesOut: *mut hiprtScene,
    ) -> hiprtError {
        (self
            .hiprtBuildScenes
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            buildOperation,
            numScenes,
            buildInputs,
            buildOptions,
            temporaryBuffer,
            stream,
            scenesOut,
        )
    }
    #[must_use]
    #[doc = " \\brief Returns temporary storage requirements for scene build.\n\n \\param context The HIPRT API context.\n \\param buildInput An input parameters for the build.\n \\param buildOptions Various flags controlling build process.\n \\param sizeOut The resulting size.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtGetSceneBuildTemporaryBufferSize(
        &self,
        context: hiprtContext,
        buildInput: *const hiprtSceneBuildInput,
        buildOptions: hiprtBuildOptions,
        sizeOut: *mut usize,
    ) -> hiprtError {
        (self
            .hiprtGetSceneBuildTemporaryBufferSize
            .as_ref()
            .expect("Expected function, got error."))(
            context, buildInput, buildOptions, sizeOut
        )
    }
    #[must_use]
    #[doc = " \\brief Returns temporary storage requirements for scene build.\n\n \\param context The HIPRT API context.\n \\param numScenes The number of scenes to be built.\n \\param buildInput An input parameters for the build.\n \\param buildOptions Various flags controlling build process.\n \\param sizeOut The resulting size.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtGetScenesBuildTemporaryBufferSize(
        &self,
        context: hiprtContext,
        numScenes: u32,
        buildInput: *const hiprtSceneBuildInput,
        buildOptions: hiprtBuildOptions,
        sizeOut: *mut usize,
    ) -> hiprtError {
        (self
            .hiprtGetScenesBuildTemporaryBufferSize
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            numScenes,
            buildInput,
            buildOptions,
            sizeOut,
        )
    }
    #[must_use]
    #[doc = " \\brief Compacts scene.\n\n This function compacts hiprtScene, reducing used memory.\n The input scene are automatically destroyed.\n\n \\param context The HIPRT API context.\n \\param stream A stream used for the compaction.\n \\param sceneIn The input scene to be compacted.\n \\param sceneOut The compacted scene.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCompactScene(
        &self,
        context: hiprtContext,
        stream: hiprtApiStream,
        sceneIn: hiprtScene,
        sceneOut: *mut hiprtScene,
    ) -> hiprtError {
        (self
            .hiprtCompactScene
            .as_ref()
            .expect("Expected function, got error."))(context, stream, sceneIn, sceneOut)
    }
    #[must_use]
    #[doc = " \\brief Compacts scenes.\n\n This function compacts an array of\n hiprtScene, reducing used memory.\n The input scenes are automatically destroyed.\n\n \\param context The HIPRT API context.\n \\param numScenes The number of scenes to be compacted.\n \\param stream A stream used for the compaction.\n \\param scenesIn The input scenes to be compacted.\n \\param scenesOut The compacted scenes.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCompactScenes(
        &self,
        context: hiprtContext,
        numScenes: u32,
        stream: hiprtApiStream,
        scenesIn: *mut hiprtScene,
        scenesOut: *mut *mut hiprtScene,
    ) -> hiprtError {
        (self
            .hiprtCompactScenes
            .as_ref()
            .expect("Expected function, got error."))(
            context, numScenes, stream, scenesIn, scenesOut,
        )
    }
    #[must_use]
    #[doc = " \\brief Creates a custom function table.\n\n \\param context The HIPRT API context.\n \\param numGeomTypes The number of geometry types.\n \\param numRayTypes The number of ray types.\n \\param funcTableOut The resulting table.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCreateFuncTable(
        &self,
        context: hiprtContext,
        numGeomTypes: u32,
        numRayTypes: u32,
        funcTableOut: *mut hiprtFuncTable,
    ) -> hiprtError {
        (self
            .hiprtCreateFuncTable
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            numGeomTypes,
            numRayTypes,
            funcTableOut,
        )
    }
    #[must_use]
    #[doc = " \\brief Sets an entry in the function table.\n\n \\param context The HIPRT API context.\n \\param funcTable The function table.\n \\param geomType The geometry type.\n \\param rayType The ray type.\n \\param set The function set to be assigned.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtSetFuncTable(
        &self,
        context: hiprtContext,
        funcTable: hiprtFuncTable,
        geomType: u32,
        rayType: u32,
        set: hiprtFuncDataSet,
    ) -> hiprtError {
        (self
            .hiprtSetFuncTable
            .as_ref()
            .expect("Expected function, got error."))(
            context, funcTable, geomType, rayType, set
        )
    }
    #[must_use]
    #[doc = " \\brief Destroys a custom function table.\n\n \\param context The HIPRT API context.\n \\param funcTable The function table.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtDestroyFuncTable(
        &self,
        context: hiprtContext,
        funcTable: hiprtFuncTable,
    ) -> hiprtError {
        (self
            .hiprtDestroyFuncTable
            .as_ref()
            .expect("Expected function, got error."))(context, funcTable)
    }
    #[must_use]
    #[doc = " \\brief Creates a stack buffer (for hiprtGlobalStack or hiprtDynamicStack).\n\n \\param context The HIPRT API context.\n \\param input The input information needed for the stack buffer allocation.\n \\param stackBufferOut The stack buffer.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCreateGlobalStackBuffer(
        &self,
        context: hiprtContext,
        input: *const hiprtGlobalStackBufferInput,
        stackBufferOut: *mut hiprtGlobalStackBuffer,
    ) -> hiprtError {
        (self
            .hiprtCreateGlobalStackBuffer
            .as_ref()
            .expect("Expected function, got error."))(context, input, stackBufferOut)
    }
    #[must_use]
    #[doc = " \\brief Destroys a stack buffer.\n\n \\param context The HIPRT API context.\n \\param stackBuffer The stack buffer.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtDestroyGlobalStackBuffer(
        &self,
        context: hiprtContext,
        stackBuffer: hiprtGlobalStackBuffer,
    ) -> hiprtError {
        (self
            .hiprtDestroyGlobalStackBuffer
            .as_ref()
            .expect("Expected function, got error."))(context, stackBuffer)
    }
    #[must_use]
    #[doc = " \\brief Saves hiprtGeometry to a binary file.\n\n \\param context The HIPRT API context.\n \\param geometry The geometry to be saved.\n \\param filename The file name with full path.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtSaveGeometry(
        &self,
        context: hiprtContext,
        geometry: hiprtGeometry,
        filename: *const ::std::os::raw::c_char,
    ) -> hiprtError {
        (self
            .hiprtSaveGeometry
            .as_ref()
            .expect("Expected function, got error."))(context, geometry, filename)
    }
    #[must_use]
    #[doc = " \\brief Loads hiprtGeometry to a binary file.\n\n \\param context The HIPRT API context.\n \\param geometryOut The geometry to be loaded.\n \\param filename The file name with full path.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtLoadGeometry(
        &self,
        context: hiprtContext,
        geometryOut: *mut hiprtGeometry,
        filename: *const ::std::os::raw::c_char,
    ) -> hiprtError {
        (self
            .hiprtLoadGeometry
            .as_ref()
            .expect("Expected function, got error."))(context, geometryOut, filename)
    }
    #[must_use]
    #[doc = " \\brief Saves hiprtScene to a binary file.\n\n \\param context The HIPRT API context.\n \\param scene The scene to be saved.\n \\param filename The file name with full path.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtSaveScene(
        &self,
        context: hiprtContext,
        scene: hiprtScene,
        filename: *const ::std::os::raw::c_char,
    ) -> hiprtError {
        (self
            .hiprtSaveScene
            .as_ref()
            .expect("Expected function, got error."))(context, scene, filename)
    }
    #[must_use]
    #[doc = " \\brief Loads hiprtScene to a binary file.\n\n \\param context The HIPRT API context.\n \\param sceneOut The scene to be loaded.\n \\param filename The file name with full path.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtLoadScene(
        &self,
        context: hiprtContext,
        sceneOut: *mut hiprtScene,
        filename: *const ::std::os::raw::c_char,
    ) -> hiprtError {
        (self
            .hiprtLoadScene
            .as_ref()
            .expect("Expected function, got error."))(context, sceneOut, filename)
    }
    #[must_use]
    #[doc = " \\brief Outputs scene's AABB.\n\n \\param context The HIPRT API context.\n \\param geometry The geometry to be queried.\n \\param aabbMinOut The bounding box min. bound.\n \\param aabbMaxOut The bounding box max. bound.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtExportGeometryAabb(
        &self,
        context: hiprtContext,
        geometry: hiprtGeometry,
        aabbMinOut: *mut hiprtFloat3,
        aabbMaxOut: *mut hiprtFloat3,
    ) -> hiprtError {
        (self
            .hiprtExportGeometryAabb
            .as_ref()
            .expect("Expected function, got error."))(
            context, geometry, aabbMinOut, aabbMaxOut
        )
    }
    #[must_use]
    #[doc = " \\brief Outputs scene AABB.\n\n \\param context The HIPRT API context.\n \\param scene The scene to be queried.\n \\param aabbMinOut The bounding box min. bound.\n \\param aabbMaxOut The bounding box max. bound.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtExportSceneAabb(
        &self,
        context: hiprtContext,
        scene: hiprtScene,
        aabbMinOut: *mut hiprtFloat3,
        aabbMaxOut: *mut hiprtFloat3,
    ) -> hiprtError {
        (self
            .hiprtExportSceneAabb
            .as_ref()
            .expect("Expected function, got error."))(context, scene, aabbMinOut, aabbMaxOut)
    }
    #[must_use]
    #[doc = " \\brief Returns function instance with HIPRT routines.\n \\param context The HIPRT API context.\n \\param numFunctions The number of functions to compile.\n \\param funcNames Functions to to be returned, cannot be nullptr.\n \\param src The module source code.\n \\param moduleName The name of the module.\n \\param numHeaders The number of headers.\n \\param headers Sources of the headers, headers can be nullptr when numHeaders is 0.\n \\param includeNames The header names to be included to the module, includeNames can be nullptr\n when numHeaders is 0.\n \\param numOptions Number of compiler options, can be 0.\n \\param options The compiler options, can be nullptr.\n \\param numGeomTypes The number of geometry types.\n \\param numRayTypes The number of ray types.\n \\param funcNameSets The table of custom function names (numRayTypes x numGeomTypes).\n \\param functionsOut The output function instances.\n \\param moduleOut The output module instance, can be nullptr.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtBuildTraceKernels(
        &self,
        context: hiprtContext,
        numFunctions: u32,
        funcNames: *mut *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        moduleName: *const ::std::os::raw::c_char,
        numHeaders: u32,
        headers: *mut *const ::std::os::raw::c_char,
        includeNames: *mut *const ::std::os::raw::c_char,
        numOptions: u32,
        options: *mut *const ::std::os::raw::c_char,
        numGeomTypes: u32,
        numRayTypes: u32,
        funcNameSets: *mut hiprtFuncNameSet,
        functionsOut: *mut hiprtApiFunction,
        moduleOut: *mut hiprtApiModule,
        cache: bool,
    ) -> hiprtError {
        (self
            .hiprtBuildTraceKernels
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            numFunctions,
            funcNames,
            src,
            moduleName,
            numHeaders,
            headers,
            includeNames,
            numOptions,
            options,
            numGeomTypes,
            numRayTypes,
            funcNameSets,
            functionsOut,
            moduleOut,
            cache,
        )
    }
    #[must_use]
    #[doc = " \\brief Get function instance with HIPRT routines.\n \\param context The HIPRT API context.\n \\param numFunctions The number of functions to compile.\n \\param funcNames Functions to to be returned, cannot be nullptr.\n \\param moduleName The name of the bitcode module.\n \\param bitcodeBinary The user compiled bitcode.\n \\param bitcodeBinarySize The size of the compiled bitcode.\n \\param numGeomTypes The number of geometry types.\n \\param numRayTypes The number of ray types.\n \\param funcNameSets The table of custom function names (numRayTypes x numGeomTypes).\n \\param functionsOut The output function instances.\n \\return A HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtBuildTraceKernelsFromBitcode(
        &self,
        context: hiprtContext,
        numFunctions: u32,
        funcNames: *mut *const ::std::os::raw::c_char,
        moduleName: *const ::std::os::raw::c_char,
        bitcodeBinary: *const ::std::os::raw::c_char,
        bitcodeBinarySize: usize,
        numGeomTypes: u32,
        numRayTypes: u32,
        funcNameSets: *mut hiprtFuncNameSet,
        functionsOut: *mut hiprtApiFunction,
        cache: bool,
    ) -> hiprtError {
        (self
            .hiprtBuildTraceKernelsFromBitcode
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            numFunctions,
            funcNames,
            moduleName,
            bitcodeBinary,
            bitcodeBinarySize,
            numGeomTypes,
            numRayTypes,
            funcNameSets,
            functionsOut,
            cache,
        )
    }
    #[doc = " \\brief Setting log level.\n \\param context The HIPRT API context.\n \\param path A user defined path to cache kernels."]
    pub unsafe fn hiprtSetCacheDirPath(
        &self,
        context: hiprtContext,
        path: *const ::std::os::raw::c_char,
    ) {
        (self
            .hiprtSetCacheDirPath
            .as_ref()
            .expect("Expected function, got error."))(context, path)
    }
    #[doc = " \\brief Sets the log level.\n\n \\param level The desired log level."]
    pub unsafe fn hiprtSetLogLevel(&self, level: hiprtLogLevel) {
        (self
            .hiprtSetLogLevel
            .as_ref()
            .expect("Expected function, got error."))(level)
    }
}
